//!
//  Geometry/Spline.h
// This file is part of the "Euclid" project, and is released under the MIT license.
#ifndef _EUCLID_GEOMETRY_SPLINE_H
#define _EUCLID_GEOMETRY_SPLINE_H

#include "../Numerics/Vector.h"
#include "../Numerics/Interpolate.h"
#include "Plane.h"

#include <functional>
#include <vector>
#include <list>

namespace Euclid {
	namespace Geometry {
		/** A generic spline interface.

		    @templatefield	D	The dimensions of the spline. Can be 2 or 3.

		    The spline interface exports basic spline methods, such as
		    point and tangent information at time t. There is also a virtual helper
		    function normal_at_time, which is not well defined for 3-space. You should
		    use SplineWithNormal to combine a normal spline with a regular spline.
		*/
		template <unsigned D>
		class ISpline {
		public:
			typedef Vector<D> VecT;
			typedef std::vector<VecT> PointsT;
			typedef std::vector<RealT> TimesT;

			virtual ~ISpline ();

			/// Retrieve the point at time t.
			virtual VecT point_at_time(RealT t) const = 0;

			/// Retrieve the spline tangent at time t.
			virtual VecT tangent_at_time(RealT t) const;

			/// Retrieve the spline normal at time t.
			/// Default implementation is not very good in 3-space. Use
			/// SplineWithNormal to avoid problems (see Hairy Ball Theorem).
			virtual VecT normal_at_time(RealT t) const;

			/// Helper method to subdivide the mesh.
			/// @param      resolution	The higher the resolution, the more detail will be present.
			///	@param		divisions	Divide at least divisions^2 times.
			///	@result     vector of times
			virtual std::vector<RealT> times_at_resolution(RealT resolution, unsigned divisions) const;

			/// Points used for drawing segments. May differ based on closed/open nature of the spline. */
			virtual const PointsT& segment_points() const {
				return points();
			}

			virtual const PointsT & points() const = 0;

			/// The number of segments along the spline.
			virtual unsigned segments () const;

			/// The index of the first point given time t.
			unsigned starting_point(RealT t) const;

			/// The fraction between two points given time t.
			RealT fractional_component(RealT t) const;

			/// Produce an array of times where points are typically defined
			///	@result     vector of times where well defined points exist
			virtual TimesT nominal_times () const;

		private:
			TimesT divide_and_append(int n, RealT res) const;
			void divide_and_append(RealT t, RealT d, int n, RealT res2, bool first, TimesT &times) const;
		};

		/** A concrete spline base class.
		    A point-based spline can inherit from this class to gain a point-based interface.
		*/
		template <unsigned D>
		class Spline : virtual public ISpline<D>{
		protected:
			typedef Vector<D> PointT;
			typedef std::vector<PointT> PointsT;

			PointsT _points;

			mutable PointsT _segment_points;
			void reset_segment_points_cache();

			/// Points used for drawing segments. Additional start point at end if closed.
			virtual PointsT generate_segment_points() const;

			bool _closed;
		public:
			Spline ();
			virtual ~Spline ();

			virtual const PointsT& points() const { return _points; }
			virtual PointsT& points() { return _points; }

			virtual bool closed () const;
			virtual void set_closed (bool closed);

			/// Points used for drawing segments. Additional start point at end if closed.
			///	@discussion	Will cache points generated by generate_segment_points, so you should
			///	typically not over-ride this function, and over-ride generate_segment_points. To indicate
			///	that the cache needs to be regenerated, call reset_segment_points_cache()
			virtual const PointsT& segment_points() const;
		};

		/** A spline plus spline normal combination.

		    This interface can be used to attach two splines together.
		    The primary spline is exposed through point_at_time and tangent_at_time,
		    while the difference of point_at_time(t) is used to provide normal_at_time(t)
		*/
		template <unsigned D>
		class SplineWithNormal : virtual public ISpline<D>{
		protected:
			typedef SplineWithNormal<D> this_t;
			typedef ISpline<D> SplineT;
			typedef Vector<D> PointT;
			typedef std::vector<PointT> PointsT;

		protected:
			const SplineT * _spline;
			const SplineT * _normal_spline;

		public:
			SplineWithNormal(const SplineT * spline, const SplineT * normal_spline);
			virtual ~SplineWithNormal ();

			/// Retrieve the primary spline tangent at time t.
			virtual Vector<D> point_at_time(RealT t) const;

			/// Retrieve the primary spline tangent at time t.
			virtual Vector<D> tangent_at_time(RealT t) const;

			/// Retrieve calculated normal information.
			virtual Vector<D> normal_at_time(RealT t) const;

			virtual const PointsT & points() const;

			static void for_spline (const SplineT * spline, const SplineT * normal_spline);
		};

		/**	A simple linear spline.

		    Tangent approximation may be curved at midpoints.
		*/
		template <unsigned D>
		class LinearSpline : public Spline<D>{
		public:
			virtual Vector<D> point_at_time(RealT t) const;
		};

		/** A basic 4-point cubic spline.
		*/
		template <unsigned D>
		class CubicSpline : public Spline<D>{
		protected:
			typedef Vector<D> PointT;
			typedef std::vector<PointT> PointsT;

			/// Cublic splines require one additional point at the start and at the
			/// end, so this function is overridden.
			virtual unsigned segments () const;

			///	A closed cubic requires in addition to a closed spline, two additional
			/// points to be wrapped, one at the start, and one at the end.
			virtual PointsT generate_segment_points() const;
		public:
			/// Retrieve the point at time t.
			virtual Vector<D> point_at_time(RealT t) const;
		};

		/**	A hermite cubic spline with programmatic mu.
		*/
		template <unsigned D>
		class HermiteSpline : public CubicSpline<D>{
		protected:
			// Tangent Helper
			inline Vector<D> tangent(unsigned n) const {
				return _tangent(this, n);
			}

			// Tangent (MU) Function
			typedef std::function<Vector<D>(const HermiteSpline<D> *spline, unsigned n)> SplineFunctionT;
			SplineFunctionT _tangent;

			typedef Vector<D> PointT;
			typedef std::vector<PointT> PointsT;
		public:
			/// Catmull-Rom tangent function
			static Vector<D> catmull_rom_spline (const ISpline<D> *spline, unsigned n);

			static Vector<D> four_point_linear_mu (const ISpline<D> *s, unsigned n);
			static Vector<D> four_point_exponential_mu (const ISpline<D>* s, unsigned n);

			/// Simple linear tangent function
			static Vector<D> multi_point_linear_mu (const ISpline<D>* s, unsigned n);

			/// Default constructor. Tangent generation by catmul_rom_spline.
			HermiteSpline () : _tangent(catmull_rom_spline) {
			}

			/// Catmull-Rom Tangent function
			///	@param		spline_func	Function pointer for tangent generation
			HermiteSpline (SplineFunctionT spline_func) : _tangent(spline_func) {
			}

			virtual Vector<D> point_at_time(RealT t) const;
		};
	}
}

#endif
